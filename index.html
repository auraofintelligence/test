<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cosmic Interactive Background â€“ FX Lab (Single File)</title>
<style>
  :root{
    --ui-bg: rgba(10,10,14,.82);
    --ui-fg: #e8eef8;
    --ui-accent: #6ee7ff;
    --ui-muted: #9aa4b2;
  }
  html,body{height:100%;margin:0;background:#06080d;color:var(--ui-fg);font:14px/1.35 system-ui,Segoe UI,Roboto,Inter,Arial}
  /* Stack: webgl base, particles layer, ui overlay */
  #stage{position:fixed;inset:0;overflow:hidden}
  canvas{position:absolute;inset:0;display:block;width:100%;height:100%;}
  #gl{z-index:0}
  #particles{z-index:1;mix-blend-mode:screen}
  /* Control panel */
  #panel{position:fixed;right:16px;top:16px;z-index:3; backdrop-filter: blur(8px); background:var(--ui-bg); border:1px solid rgba(255,255,255,.08); border-radius:16px; box-shadow: 0 10px 30px rgba(0,0,0,.4);}
  #panel header{display:flex;align-items:center;gap:.6rem; padding:.8rem 1rem; border-bottom:1px solid rgba(255,255,255,.06)}
  #panel header h1{font-size:14px;letter-spacing:.06em;margin:0;color:#cfe7ff}
  #panel .content{display:grid; grid-template-columns: 1fr 1fr; gap:.75rem 1rem; padding: .9rem 1rem 1rem; max-height: 80vh; overflow:auto}
  #panel label{display:flex; align-items:center; gap:.35rem; color:var(--ui-muted)}
  #panel input[type="range"]{width:100%}
  #panel .row{display:contents}
  #panel .full{grid-column:1/-1}
  #panel select, #panel input[type="number"], #panel input[type="color"], #panel input[type="range"]{background:#0a0d14;border:1px solid rgba(255,255,255,.08);color:var(--ui-fg); border-radius:8px;padding:.25rem .4rem}
  #panel .switch{position:relative;display:inline-flex;align-items:center;gap:.4rem;}
  #panel .switch input{accent-color:var(--ui-accent)}
  #panel .small{font-size:12px;color:var(--ui-muted)}
  #footer{position:fixed;left:16px;bottom:16px;z-index:2;color:#9fb4cc;background:rgba(10,12,16,.5);padding:.4rem .6rem;border-radius:8px;border:1px solid rgba(255,255,255,.06)}
  button{cursor:pointer;background:#0e131d;border:1px solid rgba(255,255,255,.12);color:var(--ui-fg);padding:.35rem .65rem;border-radius:10px}
  button:hover{border-color:rgba(255,255,255,.25)}
  #presets{display:flex; gap:.4rem; flex-wrap:wrap}
  .tag{font-size:11px;padding:.15rem .4rem;border:1px solid rgba(255,255,255,.12);border-radius:999px;cursor:pointer;background:#0b0f18}
  .tag:hover{border-color:rgba(255,255,255,.28)}
  @media(max-width:980px){#panel{left:16px;right:16px}}
</style>
</head>
<body>
  <div id="stage">
    <canvas id="gl"></canvas>
    <canvas id="particles"></canvas>
  </div>
  <aside id="panel" aria-label="FX Controls">
    <header>
      <h1>Cosmic FX Lab</h1>
      <div id="presets"></div>
      <div style="margin-left:auto;display:flex;gap:.4rem">
        <button id="savePreset" title="Save current knobs as preset">Save</button>
        <button id="export" title="Export lightweight background config">Export</button>
      </div>
    </header>
    <div class="content" id="controls">
      <!-- Toggles -->
      <div class="row full"><label class="switch"><input type="checkbox" id="enableParticles" checked/>Particles</label> <label class="switch"><input type="checkbox" id="enableNebula" checked/>Nebula</label> <label class="switch"><input type="checkbox" id="enableDistort"/>Distort</label> <label class="switch"><input type="checkbox" id="enableFlares"/>Flares</label></div>

      <!-- Blend + opacity -->
      <label>Blend</label>
      <select id="blendMode">
        <option value="screen" selected>screen</option>
        <option value="lighter">lighter</option>
        <option value="overlay">overlay</option>
        <option value="normal">normal</option>
        <option value="color-dodge">color-dodge</option>
      </select>
      <label>Layer Opacity</label>
      <input id="layerOpacity" type="range" min="0" max="1" step="0.01" value="0.9"/>

      <!-- Particles -->
      <label>Particles</label><div class="small">swarm count / size</div>
      <input id="particleCount" type="range" min="256" max="8000" step="64" value="2400"/>
      <input id="particleSize" type="range" min="0.8" max="4" step="0.1" value="1.6"/>

      <label>Physics</label><div class="small">attract/repel & noise</div>
      <input id="attractStrength" type="range" min="-500" max="500" step="1" value="120"/>
      <input id="noiseStrength" type="range" min="0" max="400" step="1" value="120"/>

      <label>Flow Speed</label>
      <input id="flowSpeed" type="range" min="0" max="3" step="0.01" value="1.15"/>

      <label>Particle Color A</label>
      <input id="pColorA" type="color" value="#66ccff"/>
      <label>Particle Color B</label>
      <input id="pColorB" type="color" value="#ff66cc"/>

      <!-- Nebula / Smoke (shader) -->
      <label>Nebula Scale</label>
      <input id="nebulaScale" type="range" min="0.5" max="6" step="0.01" value="2.2"/>
      <label>Nebula Speed</label>
      <input id="nebulaSpeed" type="range" min="0" max="2" step="0.01" value="0.6"/>
      <label>Nebula Intensity</label>
      <input id="nebulaIntensity" type="range" min="0" max="2.5" step="0.01" value="1.1"/>
      <label>Color 1</label>
      <input id="nColor1" type="color" value="#0a1a3a"/>
      <label>Color 2</label>
      <input id="nColor2" type="color" value="#2a0088"/>
      <label>Color 3</label>
      <input id="nColor3" type="color" value="#00a8ff"/>

      <!-- Distortion / Ripple -->
      <label>Distort Radius</label>
      <input id="distortRadius" type="range" min="0.02" max="0.6" step="0.01" value="0.22"/>
      <label>Distort Strength</label>
      <input id="distortStrength" type="range" min="0" max="1.2" step="0.01" value="0.35"/>

      <!-- Flares -->
      <label>Flares Count</label>
      <input id="flareCount" type="range" min="0" max="40" step="1" value="8"/>
      <label>Flare Pulse</label>
      <input id="flarePulse" type="range" min="0" max="2" step="0.01" value="0.8"/>

      <!-- Perf -->
      <label>Resolution Scale</label>
      <input id="resScale" type="range" min="0.5" max="1.5" step="0.01" value="1"/>
      <label>FPS Cap</label>
      <input id="fpsCap" type="range" min="24" max="120" step="1" value="60"/>

      <div class="row full">
        <button id="randomize">Randomize</button>
        <button id="reset">Reset</button>
        <span class="small" id="stats"></span>
      </div>
    </div>
  </aside>
  <div id="footer">Move mouse / touch to attract-repel & distort. Toggle modes in the panel. Works under UI layers.</div>

<script>
(() => {
  const glCanvas = document.getElementById('gl');
  const pCanvas = document.getElementById('particles');
  const ctx = pCanvas.getContext('2d');
  let dpr = Math.min(1.8, window.devicePixelRatio || 1);
  let resScale = 1.0;
  let fpsTarget = 60;
  let blendMode = 'screen';
  let running = true;

  const UI = id => document.getElementById(id);
  const state = {
    enableParticles: true,
    enableNebula: true,
    enableDistort: false,
    enableFlares: false,
    layerOpacity: 0.9,
    // particles
    particleCount: 2400,
    particleSize: 1.6,
    attractStrength: 120,
    noiseStrength: 120,
    flowSpeed: 1.15,
    pColorA: '#66ccff',
    pColorB: '#ff66cc',
    // nebula
    nebulaScale: 2.2,
    nebulaSpeed: 0.6,
    nebulaIntensity: 1.1,
    nColor1: '#0a1a3a',
    nColor2: '#2a0088',
    nColor3: '#00a8ff',
    // distort
    distortRadius: 0.22,
    distortStrength: 0.35,
    // flares
    flareCount: 8,
    flarePulse: 0.8,
  };

  const defaults = JSON.parse(JSON.stringify(state));

  // --- Resize handling ---
  function resize(){
    const w = Math.floor(window.innerWidth * dpr * resScale);
    const h = Math.floor(window.innerHeight * dpr * resScale);
    [glCanvas,pCanvas].forEach(c=>{c.width=w;c.height=h; c.style.width='100%'; c.style.height='100%';});
    if(gl) gl.viewport(0,0,w,h);
  }
  window.addEventListener('resize', resize);

  // --- Input tracking ---
  const pointer = {x:0, y:0, dx:0, dy:0, down:false};
  function updatePointer(e){
    const rect = pCanvas.getBoundingClientRect();
    let x = (e.touches? e.touches[0].clientX : e.clientX) - rect.left;
    let y = (e.touches? e.touches[0].clientY : e.clientY) - rect.top;
    x *= dpr * resScale; y *= dpr * resScale;
    pointer.dx = x - pointer.x; pointer.dy = y - pointer.y;
    pointer.x = x; pointer.y = y;
  }
  window.addEventListener('mousemove', updatePointer, {passive:true});
  window.addEventListener('touchmove', updatePointer, {passive:true});
  window.addEventListener('mousedown', ()=>pointer.down=true);
  window.addEventListener('mouseup', ()=>pointer.down=false);
  window.addEventListener('touchstart', e=>{pointer.down=true; updatePointer(e);},{passive:true});
  window.addEventListener('touchend', ()=>pointer.down=false);

  // --- Particles (CPU 2D, fast) ---
  let particles = [];
  let flowT = 0;
  function rand(a=0,b=1){return a + Math.random()*(b-a)}
  function h2rgb(h){
    const r = parseInt(h.slice(1,3),16), g=parseInt(h.slice(3,5),16), b=parseInt(h.slice(5,7),16);
    return [r,g,b];
  }
  const pColA = {rgb:[0,0,0]};
  const pColB = {rgb:[0,0,0]};
  function lerp(a,b,t){return a + (b-a)*t}
  function makeParticles(n){
    particles = new Array(n).fill(0).map(()=>({
      x: rand(0,pCanvas.width), y: rand(0,pCanvas.height),
      vx: rand(-0.2,0.2), vy: rand(-0.2,0.2),
      life: rand(0,1)
    }));
  }
  function noise2D(x,y,t){
    // Simple, cheap hash-noise; good enough for flow wiggle
    const s = Math.sin(x*0.013 + y*0.011 + t*0.8)*43758.5453;
    return s - Math.floor(s);
  }
  function stepParticles(dt){
    const {attractStrength, noiseStrength, flowSpeed, particleSize} = state;
    const ax = pointer.x, ay = pointer.y;
    const attract = attractStrength * 0.00015;
    const noiseK = noiseStrength * 0.7;
    flowT += dt * flowSpeed;
    const w = pCanvas.width, h = pCanvas.height;

    for(let i=0;i<particles.length;i++){
      const p=particles[i];
      // inverse-square attraction/repulsion
      const dx = ax - p.x, dy = ay - p.y;
      const rsq = Math.max(dx*dx + dy*dy, 50);
      const f = attract / rsq * (pointer.down? 3.5 : 1.0);
      p.vx += dx*f; p.vy += dy*f;

      // curl-ish noise flow
      const ang = noise2D(p.x*0.008, p.y*0.008, flowT)*Math.PI*2;
      p.vx += Math.cos(ang)*0.04*noiseK*dt;
      p.vy += Math.sin(ang)*0.04*noiseK*dt;

      // velocity damping
      p.vx *= 0.985; p.vy *= 0.985;

      p.x += p.vx; p.y += p.vy;
      // wrap
      if(p.x<0) p.x+=w; if(p.x>=w) p.x-=w;
      if(p.y<0) p.y+=h; if(p.y>=h) p.y-=h;
      p.life += 0.003 + (p.vx*p.vx+p.vy*p.vy)*0.0005;
      if(p.life>1) p.life=0;
    }

    // draw
    ctx.globalCompositeOperation = blendMode;
    ctx.globalAlpha = state.layerOpacity;
    ctx.clearRect(0,0,w,h);

    const [r1,g1,b1]=pColA.rgb, [r2,g2,b2]=pColB.rgb;
    ctx.beginPath();
    for(let i=0;i<particles.length;i++){
      const p=particles[i];
      const t = p.life;
      const r = Math.floor(lerp(r1,r2,t));
      const g = Math.floor(lerp(g1,g2,t));
      const b = Math.floor(lerp(b1,b2,t));
      ctx.fillStyle = `rgba(${r},${g},${b},0.9)`;
      ctx.moveTo(p.x, p.y);
      ctx.arc(p.x, p.y, particleSize*dpr, 0, Math.PI*2);
    }
    ctx.fill();

    if(state.enableFlares){ drawFlares(dt); }
  }

  // --- Lens flares / glow (2D additive) ---
  const flares = [];
  function initFlares(){
    flares.length = 0;
    const n = state.flareCount|0;
    for(let i=0;i<n;i++){
      flares.push({x: rand(0,pCanvas.width), y: rand(0,pCanvas.height), r: rand(40,240)*dpr, phase: rand(0,Math.PI*2)});
    }
  }
  function drawFlares(dt){
    const pulse = state.flarePulse;
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    for(const f of flares){
      f.phase += dt * (0.5 + Math.random()*0.3);
      const k = 0.6 + Math.sin(f.phase)*0.4 * pulse;
      const grd = ctx.createRadialGradient(f.x,f.y,0,f.x,f.y,f.r*k);
      grd.addColorStop(0,'rgba(255,255,255,0.55)');
      grd.addColorStop(0.2,'rgba(255,200,180,0.35)');
      grd.addColorStop(1,'rgba(255,255,255,0)');
      ctx.fillStyle = grd;
      ctx.beginPath(); ctx.arc(f.x,f.y,f.r*k,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  // --- WebGL shader layer (nebula + distortion) ---
  const gl = glCanvas.getContext('webgl', {antialias:false, depth:false, stencil:false, premultipliedAlpha:false});
  if(!gl){ console.warn('WebGL not available'); }

  const vsrc = `
  attribute vec2 p; varying vec2 uv; void main(){ uv = (p+1.0)*0.5; gl_Position = vec4(p,0.,1.); }
  `;
  const fsrc = `
  precision highp float; varying vec2 uv; uniform vec2 res; uniform float time; uniform vec2 pointer; 
  uniform float scale; uniform float speed; uniform float intensity; 
  uniform vec3 c1; uniform vec3 c2; uniform vec3 c3; uniform float distortR; uniform float distortS; uniform bool enableNebula; uniform bool enableDistort;

  // iq-style hash
  float hash(vec3 p){ return fract(sin(dot(p, vec3(127.1,311.7, 74.7)))*43758.5453); }
  float noise(vec3 p){ vec3 i=floor(p); vec3 f=fract(p);
    float n=0.0; for(int dx=0; dx<2; dx++) for(int dy=0; dy<2; dy++) for(int dz=0; dz<2; dz++){
      vec3 g = vec3(float(dx),float(dy),float(dz));
      float w = dot(f-g, f-g); w = max(0.0, 1.0 - w*1.6);
      n += hash(i+g) * w;
    }
    return n;
  }

  vec2 distort(vec2 p){
    vec2 d = p - pointer/res; float r = length(d);
    float m = smoothstep(distortR, 0.0, r) * distortS; // pull-in refraction
    vec2 dir = normalize(d + 1e-5);
    return p - dir * m * 0.25 * (0.5 + sin(time*1.7)*0.5);
  }

  void main(){
    vec2 p = uv; if(enableDistort){ p = distort(p); }
    vec2 q = (p*res)/min(res.x,res.y);
    float t = time*speed;
    float ns = 0.0;
    if(enableNebula){
      // multi-octave soft noise for fog/nebula
      for(int i=0;i<5;i++){
        float k = pow(2.0,float(i));
        ns += noise(vec3(q*scale/k, t*0.2 + float(i)*13.7)) / k;
      }
    }
    ns = clamp(ns*intensity, 0.0, 1.0);

    vec3 col = mix(c1, c2, ns);
    col = mix(col, c3, smoothstep(0.6,1.0,ns));

    gl_FragColor = vec4(col, 1.0);
  }
  `;

  function compile(type, src){ const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s); if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){ throw gl.getShaderInfoLog(s);} return s; }
  let prog, vao, aPos, u = {};
  function initGL(){
    if(!gl) return;
    const vs = compile(gl.VERTEX_SHADER, vsrc);
    const fs = compile(gl.FRAGMENT_SHADER, fsrc);
    prog = gl.createProgram(); gl.attachShader(prog,vs); gl.attachShader(prog,fs); gl.linkProgram(prog);
    if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw gl.getProgramInfoLog(prog);
    gl.useProgram(prog);
    aPos = gl.getAttribLocation(prog,'p');
    const quad = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
    const vbo = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vbo); gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos,2,gl.FLOAT,false,0,0);
    const loc = n=> gl.getUniformLocation(prog,n);
    u.res=loc('res'); u.time=loc('time'); u.pointer=loc('pointer');
    u.scale=loc('scale'); u.speed=loc('speed'); u.intensity=loc('intensity');
    u.c1=loc('c1'); u.c2=loc('c2'); u.c3=loc('c3'); u.distortR=loc('distortR'); u.distortS=loc('distortS');
    u.enableNebula=loc('enableNebula'); u.enableDistort=loc('enableDistort');
  }

  // --- Controls wiring ---
  function syncColors(){ pColA.rgb = h2rgb(state.pColorA); pColB.rgb = h2rgb(state.pColorB); }
  function applyBlend(){ blendMode = UI('blendMode').value; ctx.globalCompositeOperation = blendMode; }

  function bind(id, key, on){ const el = UI(id); const set = v=>{ state[key] = (typeof state[key]==='number')? +v : (typeof state[key]==='boolean'? !!v : v); if(on) on(); }; set(el.type==='checkbox'? el.checked : el.value); el.addEventListener('input', e=> set(el.type==='checkbox'? el.checked : el.value)); }

  bind('enableParticles','enableParticles');
  bind('enableNebula','enableNebula');
  bind('enableDistort','enableDistort');
  bind('enableFlares','enableFlares', initFlares);
  bind('layerOpacity','layerOpacity');
  bind('particleCount','particleCount', ()=> makeParticles(state.particleCount|0));
  bind('particleSize','particleSize');
  bind('attractStrength','attractStrength');
  bind('noiseStrength','noiseStrength');
  bind('flowSpeed','flowSpeed');
  bind('pColorA','pColorA', syncColors);
  bind('pColorB','pColorB', syncColors);
  bind('nebulaScale','nebulaScale');
  bind('nebulaSpeed','nebulaSpeed');
  bind('nebulaIntensity','nebulaIntensity');
  bind('nColor1','nColor1');
  bind('nColor2','nColor2');
  bind('nColor3','nColor3');
  bind('distortRadius','distortRadius');
  bind('distortStrength','distortStrength');
  bind('flareCount','flareCount', initFlares);
  bind('flarePulse','flarePulse');

  UI('blendMode').addEventListener('change', applyBlend);

  UI('resScale').addEventListener('input', e=>{ resScale = +e.target.value; resize(); makeParticles(state.particleCount|0); initFlares(); });
  UI('fpsCap').addEventListener('input', e=>{ fpsTarget = +e.target.value; });

  UI('randomize').addEventListener('click', ()=>{
    const r = () => Math.random();
    UI('enableNebula').checked = state.enableNebula = true;
    UI('enableParticles').checked = state.enableParticles = true;
    UI('nebulaScale').value = state.nebulaScale = lerp(0.8,4.5,r());
    UI('nebulaSpeed').value = state.nebulaSpeed = lerp(0.1,1.2,r());
    UI('nebulaIntensity').value = state.nebulaIntensity = lerp(0.6,1.8,r());
    UI('attractStrength').value = state.attractStrength = lerp(-200,280,r());
    UI('noiseStrength').value = state.noiseStrength = lerp(40,300,r());
    UI('flowSpeed').value = state.flowSpeed = lerp(0.2,2.0,r());
    UI('particleCount').value = state.particleCount = Math.floor(lerp(800,6000,r())); makeParticles(state.particleCount|0);
    UI('particleSize').value = state.particleSize = lerp(0.9,3.2,r());
    UI('pColorA').value = state.pColorA = `#${((r()*0xffffff)|0).toString(16).padStart(6,'0')}`;
    UI('pColorB').value = state.pColorB = `#${((r()*0xffffff)|0).toString(16).padStart(6,'0')}`; syncColors();
    UI('nColor1').value = state.nColor1 = `#${((r()*0xffffff)|0).toString(16).padStart(6,'0')}`;
    UI('nColor2').value = state.nColor2 = `#${((r()*0xffffff)|0).toString(16).padStart(6,'0')}`;
    UI('nColor3').value = state.nColor3 = `#${((r()*0xffffff)|0).toString(16).padStart(6,'0')}`;
  });

  UI('reset').addEventListener('click', ()=>{
    Object.assign(state, JSON.parse(JSON.stringify(defaults)));
    for(const k in state){ const el = UI(k); if(!el) continue; if(el.type==='checkbox') el.checked = state[k]; else el.value = state[k]; }
    syncColors(); applyBlend(); resize(); makeParticles(state.particleCount|0); initFlares();
  });

  // Presets save/load
  const presetEl = document.getElementById('presets');
  function loadPresets(){
    presetEl.innerHTML='';
    const data = JSON.parse(localStorage.getItem('cosmicFxPresets')||'[]');
    data.forEach((p,i)=>{
      const tag = document.createElement('span'); tag.className='tag'; tag.textContent=p.name; tag.title='Click to load';
      tag.addEventListener('click', ()=>{ Object.assign(state,p.values); for(const k in state){ const el = UI(k); if(!el) continue; if(el.type==='checkbox') el.checked = state[k]; else el.value = state[k]; } syncColors(); resize(); makeParticles(state.particleCount|0); initFlares(); });
      presetEl.appendChild(tag);
    });
  }
  UI('savePreset').addEventListener('click', ()=>{
    const name = prompt('Preset name?'); if(!name) return;
    const data = JSON.parse(localStorage.getItem('cosmicFxPresets')||'[]');
    data.push({name, values: {...state}});
    localStorage.setItem('cosmicFxPresets', JSON.stringify(data));
    loadPresets();
  });
  UI('export').addEventListener('click', ()=>{
    const cfg = {...state, resScale, fpsTarget, blendMode};
    const blob = new Blob([JSON.stringify(cfg,null,2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download='cosmic-fx-config.json'; a.click(); URL.revokeObjectURL(url);
  });

  // --- Animation loop ---
  let last=performance.now(), acc=0, frameInterval=1000/60; // logic at 60hz; render capped separately
  let lastRender=0;

  function tick(now){
    if(!running) return;
    const dt=(now-last)/1000; last=now; acc += dt;

    // Update logic in fixed steps (improves stability)
    const logicStep=1/60; while(acc>=logicStep){ if(state.enableParticles) stepParticles(logicStep); acc-=logicStep; }

    // Render GL at fps cap
    if(now-lastRender >= (1000/fpsTarget)){
      drawGL(now/1000);
      lastRender = now;
      // simple stats
      UI('stats').textContent = `${pCanvas.width}x${pCanvas.height}@${fpsTarget}fps â€¢ ${state.particleCount|0} px`;
    }
    requestAnimationFrame(tick);
  }

  function drawGL(t){
    if(!gl) return;
    gl.useProgram(prog);
    gl.disable(gl.DEPTH_TEST); gl.disable(gl.BLEND);
    gl.viewport(0,0,gl.drawingBufferWidth, gl.drawingBufferHeight);

    gl.uniform2f(u.res, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.uniform1f(u.time, t);
    gl.uniform2f(u.pointer, pointer.x, gl.drawingBufferHeight-pointer.y);

    gl.uniform1f(u.scale, state.nebulaScale);
    gl.uniform1f(u.speed, state.nebulaSpeed);
    gl.uniform1f(u.intensity, state.nebulaIntensity);

    const nc1 = h2rgb(state.nColor1), nc2=h2rgb(state.nColor2), nc3=h2rgb(state.nColor3);
    gl.uniform3f(u.c1, nc1[0]/255, nc1[1]/255, nc1[2]/255);
    gl.uniform3f(u.c2, nc2[0]/255, nc2[1]/255, nc2[2]/255);
    gl.uniform3f(u.c3, nc3[0]/255, nc3[1]/255, nc3[2]/255);

    gl.uniform1f(u.distortR, state.distortRadius);
    gl.uniform1f(u.distortS, state.distortStrength);

    gl.uniform1i(u.enableNebula, state.enableNebula?1:0);
    gl.uniform1i(u.enableDistort, state.enableDistort?1:0);

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }

  // --- Boot ---
  initGL(); applyBlend(); syncColors();
  function boot(){ resize(); makeParticles(state.particleCount|0); initFlares(); loadPresets(); requestAnimationFrame(tick); }
  boot();

  // Expose a tiny API for future lightweight embed
  window.CosmicFX = {
    set(k,v){ if(k in state){ state[k]=v; const el=UI(k); if(el){ if(el.type==='checkbox') el.checked=v; else el.value=v; } if(k==='particleCount') makeParticles(v|0); if(k==='pColorA'||k==='pColorB') syncColors(); if(k==='flareCount') initFlares(); } },
    get(k){ return state[k]; },
    export(){ return {...state, resScale, fpsTarget, blendMode}; },
  };
})();
</script>
</body>
</html>
